<!doctype html><html lang="en"><head><meta charset="utf-8"><title>What Are Web Components? — WebComponents.org</title><meta name="viewport" content="width=device-width"><meta name="google-site-verification" content="vE_TSC7WOaWmPWAQryKIW3zmibsq7sVDF6I1Tcfex7U"><meta name="description" content="Web Components allow developers to extend HTML's semantics directly, giving us
an opportunity to make ad-hoc web semantics more meaningful. In the long term,
as authors of component libraries work on &quot;standardising&quot; patterns and APIs we
can gain more flexibility in our ecosystem for UI components.
"><meta name="author" content="The Community"><meta name="application-name" content=""><meta property="og:title" content="What Are Web Components? — WebComponents.org"><meta property="og:type" content="article"><meta property="og:image" content="http://localhost:9778/img/logo.png"><meta property="og:url" content="http://localhost:9778"><meta property="og:description" content="Web Components allow developers to extend HTML's semantics directly, giving us
an opportunity to make ad-hoc web semantics more meaningful. In the long term,
as authors of component libraries work on &quot;standardising&quot; patterns and APIs we
can gain more flexibility in our ecosystem for UI components.
"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="What Are Web Components? — WebComponents.org"><meta name="twitter:description" content="Web Components allow developers to extend HTML's semantics directly, giving us
an opportunity to make ad-hoc web semantics more meaningful. In the long term,
as authors of component libraries work on &quot;standardising&quot; patterns and APIs we
can gain more flexibility in our ecosystem for UI components.
"><meta name="twitter:image" content="http://localhost:9778/img/logo.png"><link rel="stylesheet" href="http://localhost:9778/css/main.min.css"><link rel="stylesheet" href="http://localhost:9778/css/syntax-highlight.min.css"><link rel="icon" type="image/x-icon" href="http://localhost:9778/img/favicon.ico"><!--[if lt IE 10]><link rel="stylesheet" media="all" href="http://localhost:9778/css/ielt10.css"><![endif]--><link href="http://fonts.googleapis.com/css?family=Raleway:400,600,700" rel="stylesheet" type="text/css"><link rel="author" href="https://plus.google.com/+AddyOsmani/"></head><body><header class="header-bar"><div class="wrapper"><a class="logo" href="http://localhost:9778"><img src="http://localhost:9778/img/logo-menu.png" alt="WebComponents.org"></a><nav class="nav"><ul><li class="nav-item"><a href="http://localhost:9778/" class="nav-link" title="Home">Home</a></li><li class="nav-item"><a href="http://localhost:9778/articles/" class="nav-link" title="Articles">Articles</a></li><li class="nav-item"><a href="http://localhost:9778/presentations/" class="nav-link" title="Presentations">Presentations</a></li></ul></nav><ul class="social-buttons"><li class="github-btn"><iframe src="http://ghbtns.com/github-btn.html?user=WebComponentsOrg&repo=webcomponents.org&type=watch&count=true&size=small" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe></li><li class="tweet-btn"><iframe allowtransparency="true" frameborder="0" scrolling="no" src="http://platform.twitter.com/widgets/tweet_button.1359159993.html#_=1360010161235&amp;count=horizontal&amp;id=twitter-widget-0&amp;lang=en&amp;size=m&amp;text=WebComponents.org ~ The web platform specs that will change the way you build apps" class="twitter-share-button twitter-count-horizontal" style="width: 87px; height: 20px" title="Twitter Tweet Button" data-twttr-rendered="true"></iframe></li><li class="fb-btn"><iframe src="//www.facebook.com/plugins/like.php?href=http://localhost:9778&amp;send=false&amp;layout=button_count&amp;width=90&amp;show_faces=false&amp;font&amp;colorscheme=light&amp;action=like&amp;height=21&amp;appId=176947299114210" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:90px; height:21px" allowtransparency="true"></iframe></li><li class="gplus-btn"><div class="g-plusone" data-size="medium"></div><script type="text/javascript">(function() {
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
            po.src = 'https://apis.google.com/js/plusone.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
          })();</script></li></ul></div></header><div class="wrapper"><main class="layout-single"><div class="single-content"><section class="card card-story"><p class="title">What Are Web Components?</p><div class="post-info"><p class="post-author">By <a href="https://twitter.com/addyosmani">Addy Osmani</a></p><p class="post-date"><span class="icon-clock"></span> January 14th, 2014</p></div><div class="description"><p>Web Components allow developers to extend HTML&#39;s semantics directly, giving us an opportunity to make ad-hoc web semantics more meaningful. In the long term, as authors of component libraries work on &quot;standardising&quot; patterns and APIs we can gain more flexibility in our ecosystem for UI components.</p><p>Specifically, Web Components are an umbrella term for a number of in-flight web platform standards: Custom Elements, Templates, Shadow DOM and HTML Imports. These specifications work together to afford developers more powerful primitives for some of the capabilities they&#39;re used to from more monolothic libraries like jQueryUI.</p><p>One of the many compelling reasons to use Web Components are that they enable the browser to keep your code on the fast path, the shortest path for the browser to execute operations using low-level systems which minimize repaints, layout recalculations and other processes which have the potential to slow down your content being displayed on screen.</p><h2 id="custom-elements">Custom Elements</h2><p>Custom elements give us a world where everything is an element and expands HTML&#39;s existing vocabulary. It&#39;s a view of the world that cares about encapsulation where all of your resources are elements, even those that aren&#39;t necessarily visual.</p><p>This vision considers applications as being composed of smaller units - elements, such as <code>&lt;carousel&gt;</code>, <code>&lt;slider&gt;</code>, <code>&lt;gallery&gt;</code> and so on. They can be easily reused anywhere and ideally it won&#39;t matter what frameworks you&#39;ve used to create these elements. They&#39;ll just work.</p><p>You might look at this and think..how is this better than what I&#39;m using today? Well, imagine being able to semantically define your application more cleanly. Take for example tabs.</p><p>Tabs today probably get implemented using some variation of the following:</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"tabs"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"#fragment-1"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"#fragment-2"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"#fragment-3"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"fragment-1"</span>&gt;</span>
    Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"fragment-2"</span>&gt;</span>
    Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"fragment-3"</span>&gt;</span>
    Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
$( <span class="hljs-string">".selector"</span> ).tabs({ active: <span class="hljs-number">1</span> });
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><p>What if instead it could simply be...</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">my-tabs</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">my-tab</span> <span class="hljs-attribute">selected</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">my-tab</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">my-tab</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">my-tab</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">my-tab</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-title">my-tab</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">my-tabs</span>&gt;</span>
</code></pre><p>That&#39;s significantly cleaner and more semantically correct. This is the power enabled by custom elements.</p><p>We could even dynamically create this element in JS if we wanted:</p><pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> tabs = document.createElement(<span class="hljs-string">'my-tabs'</span>);
<span class="hljs-keyword">var</span> tab1 = document.createElement(<span class="hljs-string">'my-tab'</span>);
<span class="hljs-keyword">var</span> tab2 = document.createElement(<span class="hljs-string">'my-tab'</span>);
<span class="hljs-keyword">var</span> tab3 = document.createElement(<span class="hljs-string">'my-tab'</span>);
tabs.appendChild(tab1);
tabs.appendChild(tab2);
tabs.appendChild(tab3);
tab1.setAttribute(<span class="hljs-string">'selected'</span>, <span class="hljs-literal">true</span>);
</code></pre><h4 id="document-registerelement-">document.registerElement()</h4><p>To create our own custom element <code>&lt;x-panel&gt;</code> we use a new method <code>document.registerElement()</code> as follows:</p><pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> XPanel = document.registerElement(<span class="hljs-string">'x-panel'</span>);
document.body.appendChild(<span class="hljs-keyword">new</span> XPanel());
</code></pre><p>after which I can begin using it in my page. Before a custom element can be used it needs to be registered, otherwise the browser will consider it a regular <code>HTMLElement</code>.</p><p><code>document.registerElement()</code> accepts two arguments: the first is the element&#39;s tag name, which according to the specs needs to contain a dash (<code>-</code>) to enable the parser to tell the difference between standard browser tags and user-land tags (e.g <code>g-carousel</code>, <code>x-tag</code>, <code>polymer-slider</code> etc). The second argument (which is entirely optional) describes the element&#39;s prototype which can contain public methods and properties.</p><p>Taking this further, we can look at an imperative version of the above example where we register <code>&lt;x-panel&gt;</code> with some inline markup to be rendered:</p><pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> XPanelProto = <span class="hljs-built_in">Object</span>.create(HTMLElement.prototype);

XPanelProto.createdCallback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.innerHTML = <span class="hljs-string">"&lt;b&gt;I'm an x-panel-markup.&lt;/b&gt;"</span>;
};

XPanelProto.foobar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  console.log(<span class="hljs-string">'foobar!'</span>);
};

<span class="hljs-keyword">var</span> XPanel = document.registerElement(<span class="hljs-string">'x-panel-markup'</span>, {prototype: XPanelProto});

<span class="hljs-comment">/*
How it looks when rendered:
▾&lt;x-panel-markup&gt;
   &lt;b&gt;I'm an x-panel-markup element.&lt;/b&gt;
 &lt;/x-panel-markup&gt;
*/</span>
</code></pre><p>As per the documentation for the Custom Elements polyfill, the prototype has to be chained to <code>HTMLElement.prototype</code> in order for this to correctly function.</p><p>Extending elements can also easily be done, by declaring the type of element we wish to extend when registering out element using <code>extends</code>:</p><pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> XPanelButtonPrototype = <span class="hljs-built_in">Object</span>.create(HTMLButtonElement.prototype);

XPanelButtonPrototype.createdCallback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">"I'm an x-panel button"</span>;
};

<span class="hljs-keyword">var</span> XPanelButton = document.registerElement(<span class="hljs-string">'x-panel-button'</span>, {
  prototype: XPanelButtonPrototype,
  extends: <span class="hljs-string">'button'</span>
});
</code></pre><p>Also relevant:</p><p>Create an instance of a new element <code>x-foo</code> using <code>new</code>:</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">// register x-foo</span>
<span class="hljs-keyword">var</span> XFoo = document.registerElement(<span class="hljs-string">'x-foo'</span>, {prototype: <span class="hljs-built_in">Object</span>.create(HTMLElement.prototype)});

<span class="hljs-comment">// create an instance via new</span>
<span class="hljs-keyword">var</span> xfoo = <span class="hljs-keyword">new</span> XFoo();
</code></pre><p>Create an instance of a new element with <code>createElement</code>:</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">// register x-foo</span>
<span class="hljs-keyword">var</span> XFoo = document.registerElement(<span class="hljs-string">'x-foo2'</span>, {prototype:  <span class="hljs-built_in">Object</span>.create(HTMLElement.prototype)});

<span class="hljs-comment">// create an instance via createElement</span>
<span class="hljs-keyword">var</span> xfoo = document.createElement(<span class="hljs-string">'x-foo2'</span>);
</code></pre><p>Extend a native element <code>button</code>:</p><pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> XBarPrototype = <span class="hljs-built_in">Object</span>.create(HTMLButtonElement.prototype);
    <span class="hljs-keyword">var</span> XBar = document.registerElement(<span class="hljs-string">'x-bar'</span>, {
      prototype: XBarPrototype,
      extends: <span class="hljs-string">'button'</span>
    });

<span class="hljs-keyword">var</span> xbar = <span class="hljs-keyword">new</span> XBar();
</code></pre><h4 id="read-more">Read more</h4><ul><li><a href="www.html5rocks.com/en/tutorials/webcomponents/customelements/">HTML5 Rocks: Custom Elements</a></li><li><a href="http://www.polymer-project.org/platform/custom-elements.html">Polymer Project: Custom Elements</a></li></ul><h3 id="templating">Templating</h3><p>As most of us are aware, templates are a clean way to separate our markup and logic to maximise on code reuse and maintainability.</p><p>The syntax used to denote placeholders in templates has always depended on the template engine being used, but you&#39;ve probably used a variation of <code>{{name}}</code> in your own apps.</p><p>In the JavaScript world, templating typically involves two phases: compiling the template (parsing and turning it into a function), which concatenates our content in an optimised way and rendering the final result by placing data into the template (filling our placeholders).</p><p>Where in past years we heavily relied on JavaScript templating libraries, Web Components give us declarative native HTML templates instead via the <code>&lt;template&gt;</code> tag.</p><h3 id="-lt-template-gt-">&lt;template&gt;</h3><p><code>&lt;template&gt;</code> offers a mechanism for holding client-side content that isn&#39;t to be rendered when the page is loaded, but instead instantiated at runtime via JS.</p><p>So, <code>&lt;template&gt;</code> is parsed by the browser but does&#39;t get rendered to the page as the markup is considered inert (to an extent). This means that CSS styles will not be applied.</p><p>Here we can declare an inert template as follows:</p>&lt;template id=&quot;myTemplate&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;avatar&quot;&gt; &lt;div class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;/template&gt;<p>Then activate the template. We do this by creating a deep copy of the template <code>.content</code> by using <code>document.importNode()</code>:</p><p><code>document.importNode()</code> creates a copy of a node from an external source or document that can be inserted into the current document. The method signature is <code>importNode(externalNode, deep)</code> where <code>externalNode is</code> the node from the other document we wish to import and <code>deep</code> is a boolean indicating whether the descendants of the imported node should also be imported.</p>var template = document.querySelector('#myTemplate'); // Set the src of our avatar during runtime template.content.querySelector('img').src = 'avatar.png'; var clone = document.importNode(template.content, true); document.body.appendChild(clone);<p>As Eric Bidelman has pointed out on HTML5Rocks whilst templates are extremely powerful they do come with some downsides such as the template not being 100% inert - although the content is hidden, a network request for the avatar is still made in the above example.</p><ul><li><a href="www.html5rocks.com/en/tutorials/webcomponents/template/">HTML5 Rocks: The Template Tag</a></li><li><a href="http://www.broken-links.com/2013/04/10/the-template-element/">Broken Links: The template element</a></li></ul><h3 id="shadow-dom">Shadow DOM</h3><p>Shadow DOM gives us a way to properly encapsulate markup (&quot;hidden DOM elements&quot;), give our elements their own style boundaries (shadow boundaries) to avoid styles leaking and offering some of the same capabilities browser vendors like Chrome have used to implement their own custom form elements using just HTML, CSS and JS.</p><p>Styles in your Shadow DOM get scoped (to a ShadowRoot) by default and unless you explicitly let them, they won&#39;t leak across elements (but can if you want).</p><p>In the following example, H2 styles below are scoped to ShadowRoot, so they don&#39;t bleed into the rest of the page:</p><p>HTML:</p>&lt;div&gt;&lt;h3&gt;The Light DOM&lt;/h3&gt;&lt;/div&gt;<p>JS:</p><pre class="highlight"><code class="xml">var root = document.querySelector('span').createShadowRoot();
root.innerHTML = '<span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css"><span class="hljs-tag">h2</span><span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> pink</span></span>; <span class="hljs-rule">}</span></span></span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>' + 
                 '<span class="hljs-tag">&lt;<span class="hljs-title">h3</span>&gt;</span>Im your Shadow DOM!!<span class="hljs-tag">&lt;/<span class="hljs-title">h3</span>&gt;</span>';
</code></pre><p>Encapsulation of content (e.g text) with Shadow DOM is also possible:</p><pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> XFooProto = <span class="hljs-built_in">Object</span>.create(HTMLElement.prototype);

XFooProto.createdCallback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-comment">// 1. Attach a shadow root on the element.</span>
  <span class="hljs-keyword">var</span> shadow = <span class="hljs-keyword">this</span>.createShadowRoot();

  <span class="hljs-comment">// 2. Fill it with markup.</span>
  shadow.innerHTML = <span class="hljs-string">"&lt;b&gt;I'm in the element's Shadow DOM.&lt;/b&gt;"</span>;
};

<span class="hljs-keyword">var</span> XFoo = document.registerElement(<span class="hljs-string">'x-foo-shadowdom'</span>, {prototype: XFooProto});
</code></pre><p>A glossary of Shadow DOM terms and their explanations can be found below:</p><ul><li><p>shadow host: an element that hosts one or more node trees.</p></li><li><p>shadow tree: a node tree hosted by a shadow host.</p></li><li><p>shadow root: the root node of a shadow tree.</p></li><li><p>:host - select and style the element hosting a shadow tree. Style the exterior of your element, like a border.</p></li><li><p>shadow boundary: refers to the barrier that separates the regular DOM (the “light” DOM) from the shadow DOM. One of the primary benefits of the shadow boundary is that it prevents styles that are in the main document from leaking into the shadow DOM. (This means that even though you might have a selector in your main document for all <code>&lt;h3&gt;</code> tags, that style will not be applied to your shadow DOM element unless you specifically allow it)</p></li></ul><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
      <span class="hljs-tag">button</span> <span class="hljs-rules">{
        <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">18</span>px</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> cursive</span></span>;
      <span class="hljs-rule">}</span></span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">button</span>&gt;</span>I'm a regular button<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
      <span class="hljs-keyword">var</span> host = document.querySelector(<span class="hljs-string">'div'</span>);
      <span class="hljs-keyword">var</span> root = host.createShadowRoot();
      root.innerHTML = <span class="hljs-string">'&lt;style&gt;button { font-size: 24px; color: blue; } &lt;/style&gt;'</span> +
                       <span class="hljs-string">'&lt;button&gt;I\'m a shadow button&lt;/button&gt;'</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
</code></pre><ul><li><p>Cat selector: A selector of the form A ^^ B ignores all shadow boundaries and matches the arbitrary descendant element B. Put simply, ^^ crosses any number of shadow boundaries.</p></li><li><p>Hat selector: The ^ combinator is generally equivalent to a descendant combinator (e.g. div p {...}), except it crosses one shadow boundary.</p></li><li><p>Scoped styles: styles which are scoped to the shadow root and are thus encapsulated.</p></li><li><p>shadow insertion point: A shadow DOM subtree can use a <code>&lt;content&gt;</code> element to specify an insertion point in the rendered output. The host&#39;s children are displayed at the insertion point. The <code>&lt;content&gt;</code> element acts as an insertion point for rendering only—it does not change where the elements appear in DOM.</p></li><li><p>Reprojection: Elements in a shadow DOM subtree may have shadow roots of their own. When this happens, the insertion points of the nested shadow DOM subtree act on the nodes in the outer shadow DOM subtree&#39;s insertion points.</p></li><li><p>.resetStyleInheritance: resets inheritable properties to initial at the boundary. Only allow the direct styles while resetting anything that would be inherited.</p></li></ul><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">var</span> host = document.querySelector(<span class="hljs-string">'.article'</span>);
  <span class="hljs-keyword">var</span> root = host.createShadowRoot();
  root.resetStyleInheritance = <span class="hljs-literal">true</span>; 
  root.applyAuthorStyles = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">var</span> template = document.querySelector(<span class="hljs-string">'.article-template'</span>);
  root.appendChild(template.content.cloneNode(<span class="hljs-literal">true</span>));
  template.remove();
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><ul><li><p>.applyAuthorStyles: styles defined in the author&#39;s document are applied. Think of this as allowing styles to &quot;bleed&quot; across the boundary. This is great for things like typography where you want your component to use the same font families and header sizes as the parent document.</p></li><li><p>::content - a way to target nodes that pass through an insertion point.</p></li></ul><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
    <span class="hljs-tag">body</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">font-family</span>:<span class="hljs-value"> Helvetica, Arial, sans-serif</span></span>;
    <span class="hljs-rule">}</span></span>

    <span class="hljs-tag">h2</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">text-decoration</span>:<span class="hljs-value"> underline</span></span>;
    <span class="hljs-rule">}</span></span>

    <span class="hljs-tag">p</span> <span class="hljs-rules">{
      <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">18</span>px</span></span>;
      <span class="hljs-rule"><span class="hljs-attribute">font-weight</span>:<span class="hljs-value"> bold</span></span>;
    <span class="hljs-rule">}</span></span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>This h2 is NOT in the shadow DOM<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Neither is this paragraph<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"article"</span>&gt;</span>Some interesting article content<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"article-template"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>An Article Header<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">var</span> host = document.querySelector(<span class="hljs-string">'.article'</span>);
    <span class="hljs-keyword">var</span> root = host.createShadowRoot();
    root.applyAuthorStyles = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// Note that you can also reset styles on a per &lt;shadow&gt; or</span>
    <span class="hljs-comment">// per &lt;content&gt; basis</span>
    <span class="hljs-comment">// http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-shadow-resetstyles</span>
    <span class="hljs-keyword">var</span> template = document.querySelector(<span class="hljs-string">'.article-template'</span>);
    root.appendChild(template.content.cloneNode(<span class="hljs-literal">true</span>));
    template.remove();
  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
</code></pre><ul><li>distributed nodes: Contents which come from the page and are added to the shadow DOM using the <code>&lt;content&gt;</code> tag are know as distributed nodes. distributed nodes need to be styled with the <code>::content</code> pseudo selector.</li></ul><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"widget"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">button</span>&gt;</span>Distributed Awesomesauce<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"widget-template"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
      <span class="hljs-pseudo">::content</span> &gt; <span class="hljs-tag">button</span> <span class="hljs-rules">{
        <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">18</span>px</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> white</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value"> tomato</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"> <span class="hljs-number">10</span>px</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> none</span></span>;
        <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">10</span>px</span></span>;
      <span class="hljs-rule">}</span></span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">content</span> <span class="hljs-attribute">select</span>=<span class="hljs-value">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">content</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">var</span> host = document.querySelector(<span class="hljs-string">'.widget'</span>);
    <span class="hljs-keyword">var</span> root = host.createShadowRoot();
    <span class="hljs-keyword">var</span> template = document.querySelector(<span class="hljs-string">'.widget-template'</span>);
    root.appendChild(template.content.cloneNode(<span class="hljs-literal">true</span>));
    template.remove();
  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
</code></pre><ul><li><content>: You, the component author, define how composition works with your widget using a new element called <code>&lt;content&gt;</code>. This creates an insertion point in the presentation of the widget, and the insertion point cherry-picks content from the shadow host to present at that point. By separating content and presentation, we can simplify the code that manipulates the content.</content></li></ul><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"nameTagTemplate"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
  …
</span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"outer"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"boilerplate"</span>&gt;</span>
    Hi! My name is
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"name"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">content</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre><ul><li>host states: One of the best uses of the <code>:host</code> tag is for styling states like <code>:hover</code> or <code>:active</code>. For instance, let’s say you want to add a green border to a button when the user rolls over it.</li></ul><h4 id="read-more">Read more</h4><ul><li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">HTML5 Rocks: Shadow DOM Styling</a></li><li><a href="http://robdodson.me/blog/2013/08/29/shadow-dom-styles-cont-dot/">Rob Dodson: Shadow DOM Styles</a></li><li><a href="http://www.polymer-project.org/articles/styling-elements.html">Polymer Project: A guide to styling elements</a></li></ul><h3 id="html-imports">HTML Imports</h3><p>For a long time, the web has had a few different ways of loading different kinds of resources on the web. CSS has <code>link rel=&quot;stylesheet&quot;</code>, JS has the <code>script</code> tag, but what about HTML?. We&#39;ve had <code>frames</code> and although you can use AJAX, you shouldn&#39;t <em>need</em> JavaScript to load up HTML.</p><p>HTML Imports change that but introducing a way to include documents composed of HTML in other documents in a clean way. Imports can contain markup, but they can also contain anything else you&#39;re used to (including CSS, JS, images and so on).</p><p>Importing elements into a page can be done by declaring <code>&lt;a link rel=&quot;import&quot;&gt;</code>. We would typically do this in the document <code>&lt;head&gt;</code>:</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"my-import.html"</span>&gt;</span>
</code></pre><p>Per HTML5Rocks, the browser is intelligent enough to de-duplicate requests made to the same URL so that if multiple imports request the same file, they are only ever retrieved once.</p><p>Using imports, we could import a number of documents composed of custom elements as follows:</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"my-panel.html"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"my-button.html"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"my-ratings.html"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"my-gallery.html"</span>&gt;</span>
</code></pre><p>and then start using them in our page straight away:</p><pre class="highlight"><code class="lasso"><span class="hljs-subst">&lt;</span>my<span class="hljs-attribute">-panel</span><span class="hljs-subst">&gt;</span>
  <span class="hljs-subst">&lt;</span>my<span class="hljs-attribute">-gallery</span> maxImages<span class="hljs-subst">=</span><span class="hljs-string">"5"</span><span class="hljs-subst">&gt;&lt;</span>/my<span class="hljs-attribute">-gallery</span><span class="hljs-subst">&gt;</span>
  <span class="hljs-subst">&lt;</span>my<span class="hljs-attribute">-ratings</span> <span class="hljs-keyword">min</span><span class="hljs-subst">=</span><span class="hljs-string">"0"</span> <span class="hljs-keyword">max</span><span class="hljs-subst">=</span><span class="hljs-string">"10"</span><span class="hljs-subst">&gt;&lt;</span>/my<span class="hljs-attribute">-ratings</span><span class="hljs-subst">&gt;</span>
  <span class="hljs-subst">&lt;</span>my<span class="hljs-attribute">-button</span> caption<span class="hljs-subst">=</span><span class="hljs-string">"Vote!"</span><span class="hljs-subst">&gt;&lt;</span>/my<span class="hljs-attribute">-button</span><span class="hljs-subst">&gt;</span>
<span class="hljs-subst">&lt;</span>/my<span class="hljs-attribute">-panel</span><span class="hljs-subst">&gt;</span>
</code></pre><h3 id="read-more">Read more</h3><ul><li><a href="www.html5rocks.com/en/tutorials/webcomponents/imports/">HTML5 Rocks: HTML Imports #include for the web</a></li><li><a href="http://robdodson.me/blog/2013/08/20/exploring-html-imports/">Rob Dodson: Exploring HTML Imports</a></li></ul></div></section><div class="card card-comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'webcomponentsorg';

                  (function() {
                      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();</script></div></div><div class="single-sidebar"><section class="card card-author"><img class="author-avatar" src="https://2.gravatar.com/avatar/96270e4c3e5e9806cf7245475c00b275" alt="Addy Osmani"><p class="author-name">Addy Osmani</p><p class="author-twitter"><a href="https://twitter.com/addyosmani">@addyosmani</a></p><p class="author-bio">Addy works on the Chrome Developer Relations team at Google, building and advocating for tools to help improve developer productivity and satisfaction. His personal projects include TodoMVC, which helps developers compare JavaScript MVC frameworks and AuraJS. He've also written 'Developing Backbone.js Applications' and 'Learning JavaScript Design Patterns'.</p></section></div></main></div><footer class="credits"><p>Made with <span class="love">♥</span> by the <a href="https://github.com/WebComponentsOrg/webcomponents.org/graphs/contributors">WebComponents.org contributors.</a></p></footer><!--[if lt IE 9]><script src="http://localhost:9778/vendor/respond/respond.src.js"></script><![endif]--><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-47408119-1', 'webcomponentsorg.github.io');
      ga('send', 'pageview');</script></body></html>